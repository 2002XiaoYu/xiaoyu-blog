# 第十二周：程序结构

## 12.1-1全局变量：定义在函数之外的变量，全局的生存期和作用域

### 全局变量

1. 定义在函数外面的变量是全局变量
2. 全局变量具有全局的生存期和作用域

3. 1. 他们和任何函数无关
   2. 在任何函数内部都可以使用他们

```c
#include<stdio.h>

int f(void);

int gAll = 12;//全局变量

int main(int argc,char const *argv[])
{
    printf("in %s gAll=%d\n",__func__,gAll);
    f();
    printf("agn in %s gAll = %d\n",__func__,gAll);
    return 0;
}
//_func_是一个字符串，表达的是当前函数的名字，也就是main的名字
int f(void)
{
    printf("in %s gAll=%d\n",__func__,gAll);
    gAll += 2;
    printf("agn in %s gAll=%d\n",__func__,gAll);
    return gAll;
}
```

### 全局变量初始化

1. 没有做初始化的全局变量会得到0值

2. 1. 指针会得到NULL值

3. 只能用编译时刻已知的值来初始化全局变量
4. 它们的初始化发生在main函数之前

#### 被隐藏的全局变量

1. 如果函数内部存在与全局变量同名的变量，则全局变量被隐藏(局部的优先度会更高噢，会覆盖掉外面的变量)

## 12.1-2静态本地变量：能在函数结束后继续保有原值的本地变量

### 静态本地变量

1. 在本地变量定义时加上static修饰符就成为静态本地变量
2. 当函数离开的时候，静态本地变量会继续存在并保持其值
3. 静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数时会保持上次离开时的值

```c
#include<stdio.h>

int f(void);

int gAll = 12;//全局变量

int main(int argc,char const *argv[])
{
    f();
    f();
    f();
    return 0;
}
//_func_是一个字符串，表达的是当前函数的名字，也就是main的名字
int f(void)
{
    static int all = 1;
    printf("in %s gAll=%d\n",_func_,gAll);
    gAll += 2;
    printf("agn in %s gAll=%d\n",_func_,gAll);
    return gAll;
}
```

1. 静态本地变量实际上是特殊的全局变量
2. 它们(静态本地变量和全局变量)位于相同的内存区域
3. 静态本地变量具有全局的生存期，函数内的局部作用域
4. static 在这里的意思是局部作用域(本地可访问)

## 12.1-3后记：返回指针的函数，使用全局变量的贴士

### *返回指针的函数

1. 返回本地变量的地址是危险的
2. 返回全局变量或静态本地变量的地址是安全的
3. 返回在函数内malloc的内存是安全的，但是容易造成问题
4. 最好的做法是返回传入的指针

#### tips(贴士)

1. 不要使用全局变量来在函数间传递参数和结果
2. 尽量避免使用全局变量

3. 1. 丰田汽车的案子(ks)  这里给出传送门(想知道的可以看看)：https://www.sohu.com/a/133455549_464086

4. *使用全局变量和静态本地变量的函数是线程不安全的

## 12.2-1宏定义

### 编译预处理指令

1. \#开头的是编译预处理指令
2. 它们不是c语言的成分，但是C语言程序离不开它们
3. \#define用来定义一个宏 ，其实只是一个原始的文本替换

### #define

1. \#define<名字><值>
2. 注意没有结尾的分号，因为不是c的语句
3. 名字必须是一个单词，值可以是各种东西
4. 在C语言的编译器开始编译之前，编译预处理程序(cpp)会把程序中的名字换成值

5. 1. 完全的文本替换

6. gcc——save-temps

### 宏

1. 如果一个宏的值中有其他宏的名字，也是会被替换的
2. 如果一个宏的值超过来一行，最后一行之前的行末需要加\
3. 宏的值后面出现的注释不会被当作宏的值的一部分

### 没有值的宏

1. \#define_DEBUG
2. 这里宏是用于条件编译的，后面有其他的编译预处理指令来检查这个宏是否已经被定义过了

#### 预定义的宏

1. _LINE_表达代码所在的行号
2. _FILE_表达代码所在的文件名
3. _DATE_编译时候的日期
4. _TIME_编译时候的时间
5. _STDC_

## 12.2-2带参数的宏

### 像函数的宏

1. \#define cube(x)((x)*(x)*(x))
2. 宏可以带参数

```c
#include <stdio.h>

#define cube(x)((x)*(x)*(x))

int main(int argc,char const *argv[])
{
    printf("%d\n",cube(5));
    //cube(5)会被替换成cube((5)*(5)*(5));
    
    return 0;
}
```

#### 错误定义的宏

1. \#define RADTODEG(x)(x*57.29578)
2. \#define RADTODEG(x)(x)*57.29578

#### 带参数的宏的原则

1. 一切都要括号

1. 1. 整个值要括号
   2. 参数出现的每个地方都要括号

1. \#define RADTODEG(x)((x)*57.29578)

#### 带参数的宏

1. 可以带多个参数

2. 1. \#define MIN(a,b)((a)>(b)?(b):(a))

3. 也可以组合(嵌套)使用其他宏
4. 定义宏的时候后面千万不要加分号
5. 在大型程序的代码中使用非常普遍
6. 可以非常复杂，如"产生"函数

7. 1. 在#和##这两个运算符的帮助下

8. 存在中西方文化差异
9. 部分宏会被inline函数替代

#### 宏的缺陷

没有可以去检查宏有没有问题的机制

#### 其他预编译

1. 条件编译
2. error
3. ...

## 12.3-1多个源代码文件

### 多个.c文件

1. main()里的代码太长了适合分成几个函数
2. 一个源代码文件太长了适合分成几个文件
3. 两个独立的源代码文件不能编译形成可执行的程序

#### 项目

- 因为看的是翁恺老师2014年的版本(比后来的课程内容多不少，后来的课程缩水了或者说是拆分了)，所以这部分已经有更好的就进行省略了

### 编译单元

1. 一个.c文件是一个编译单元
2. 编译器每次编译只处理一个编译单元

## 12.3-2头文件

1. 把函数原型放到一个头文件(以.h结尾)中,在需要调用这个函数的源代码文件(c文件)中#include这个头文件，就能让编译器在编译的时候知道函数的原型

### #include

1. \#include是一个编译预处理指令,和宏一样，在编译之前就处理了
2. 它把那个文件的全部文本内容原封不动地插入到它所在的地方
3. 所以也不是一定要在.c文件的最前面#include

### “”还是<>

1. \#include有两种形式来指出要插入的文件

2. 1. “”要求编译器首先在当前目录(.c文件所在的目录)寻找这个文件,如果没有,到编译器指定的目录去找，例如“MAX.h”啥的自己设定的那些
   2. <>让编译器只在指定的目录去找，例如<stdio.h>

3. 编译器自己知道自己的标准库的头文件在哪里
4. 环境变量和编译器命令行参数也可以指定寻找头文件的目录

### #include的误区

1. \#include不是用来引入库的
2. stdio.h里只有printf的原型，printf的代码在另外的地方，某个.lib(Windows)或.a(Unix)中
3. 现在的C语言编译器默认会引入所有的标准库
4. \#include<stdio.h>只是为了让编译器指定printf函数的原型，保证年调用时给出的参数值是正确的类型

### 头文件

1. 在使用和定义这个函数的地方都应该%include这个头文件
2. 一般的做法就是任何.c都有对应的同名的.h，把所有对外公开的函数的原型和全局变量的声明都放进去
3. 全局变量是可以在多个.c之间共享的

### 不对外公开的函数

1. 在函数前面加上static就使得它成为只能在所在的编译单元中被使用的函数
2. 在全局变量前面加上static就使得它成为只能在所在的编译单元中被使用的全局变量了

## 12.3-3声明

### 变量的声明

1. int i;是变量的定义
2. extern int i;是变量的声明

### 声明和定义

1. 声明是不产生代码的东西

1. 1. 函数原型
   2. 变量声明
   3. 结构声明
   4. 宏声明
   5. 枚举声明
   6. 类型声明
   7. inline函数

1. 定义是产生代码的东西

### 头文件

1. 只有声明可以被放在头文件中

1. 1. 是规则不是法律

1. 否则会造成一个项目中多个编译单元里有重名的实体

1. 1. *某些编译器允许几个编译单元中存在同名的函数，或者用week修饰符来强调这种存在

### 重复声明

1. 同一个编译单元里，同名的结构不能被重复声明
2. 如果你的头文件里有结构的声明，很难这个头文件不会在一个编译单元里被#include多次所以需要"标准头文件"



### 标准头文件结构

1. 运用条件编译和宏，保证这个头文件在一个编译单元中只会被#include一次
2. \#pragma once也能起到相同的作用，但是不是所有的编译器都支持

```c
#ifndef __LIST_HEAD__
#define __LIST_HEAD__

#include"node.h"

typedef struct _list{
    Node*head;
    Node*tail;
}List;

#endif
```
